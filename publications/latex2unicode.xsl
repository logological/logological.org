<?xml version="1.0" encoding="utf-8"?>
<!--
     Produce BibTeX code which converts LaTeX to HTML entities
     $Id: latex2unicode.xsl,v 1.11 2005/06/11 23:57:42 psy Exp $

     Copyright (C) 2005 Tristan Miller

     This style expects as input the SGML/XML character entities
     reference file from <http://www.bitjungle.com/~isoent/>

     str:replace template used with permission from:
     Mangano, Sal. XSLT Cookbook. O'Reilly, 2003. ISBN 0-596-00372-2.

     To include the output in a .bst file, use the shell script
     split_trans.
-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0"
  xmlns:str="http://www.ora.com/XSLTCookbook/namespaces/strings"
  extension-element-prefixes="str">

  <xsl:output method="text"/>
  <xsl:strip-space elements="*"/>

  <xsl:template match="/">
    <xsl:text>% &#x24;Id: &#x24;
%
% This file is generated by the following command line:
%
% xsltproc latex2unicode.xsl ent.xml | uniq
%
% It should then manually edited to remove various undesirable lines
% (text ligatures, duplicate search strings, ASCII letters).  The
% following lines must also be manually added (taking care to preserve
% the file's sort order, which is by string length):
%
%  "\BibTeX"  "BibT&#x3C;sub&#x3E;&#x3C;big&#x3E;E&#x3C;/big&#x3E;&#x3C;/sub&#x3E;X"  find.replace
%  "\LaTeX"  "L&#x3C;sup&#x3E;A&#x3C;/sup&#x3E;T&#x3C;sub&#x3E;&#x3C;big&#x3E;E&#x3C;/big&#x3E;&#x3C;/sub&#x3E;X"  find.replace
%  "\slash"  "/"  find.replace
%  "\TeX"  "T&#x3C;sub&#x3E;&#x3C;big&#x3E;E&#x3C;/big&#x3E;&#x3C;/sub&#x3E;X"  find.replace
%  "!!"  "&amp;#x203C;"  find.replace
%  "\@ "  " "  find.replace
%  "\ "  " "  find.replace
%  "{"  ""  find.replace
%  "}"  ""  find.replace
%
% The file is then processed by the split_trans script to produce
% BibTeX code, which can then be inserted into a .bst file.
%&#xa;</xsl:text>
    <xsl:for-each select="isoent/char/latex/seq">
      <xsl:sort select="string-length(.)" data-type="number" order="descending"/>
      <xsl:sort select="."/>
      <xsl:if test="../../unicode != '' and not(@env)">
        <xsl:choose>
          <xsl:when test="contains(., '&#34;')">
            <xsl:text>  "</xsl:text>
            <xsl:call-template name="str:replace">
              <xsl:with-param name="input">
                <xsl:value-of select="."/>
              </xsl:with-param>
              <xsl:with-param name="search-string">"</xsl:with-param>
              <xsl:with-param name="replace-string">" quote$ * "</xsl:with-param>
            </xsl:call-template>
            <xsl:text>" *</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>  "</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>"</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:text>  "&amp;</xsl:text>
        <xsl:choose>
          <xsl:when test="../../entity[starts-with(@set,'html')]">
            <xsl:value-of select="../../entity/@name"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>#x</xsl:text>
            <xsl:value-of select="../../unicode/@value"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:text>;"  find.replace&#xa;</xsl:text>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="str:replace">
    <xsl:param name="input"/>
    <xsl:param name="search-string"/>
    <xsl:param name="replace-string"/>
    <xsl:choose>
      <!-- See if the input contains the search string -->
      <xsl:when test="contains($input,$search-string)">
        <!-- If so, then concatenate the substring before the search
             string to the replacement string and to the result of
             recursively applying this template to the remaining
             sub-string. -->
        <xsl:value-of select="substring-before($input,$search-string)"/>
        <xsl:value-of select="$replace-string"/>
        <xsl:call-template name="str:replace">
          <xsl:with-param name="input"
            select="substring-after($input,$search-string)"/>
          <xsl:with-param name="search-string" 
            select="$search-string"/>
          <xsl:with-param name="replace-string" 
            select="$replace-string"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- There are no more occurences of the search string so
             just return the current input string -->
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>


<!--
<char pos="005" cat="spc">
 <entity name="numsp" set="iso-8879-pub">
  <desc>=digit space (width of a number)</desc>
 </entity>
 <unicode value="2007">
  <desc>FIGURE SPACE</desc>
 </unicode>
 <latex>
  <seq>\hphantom{0}</seq>
 </latex>
</char>
-->
